# TCP/IP 相关的问题

### 目录

---
<a href="#1">1. 一.OSI 与 TCP/IP 各层的结构与功能,都有哪些协议,协议所占端口号。</a> <br>
<a href="#2">2. IP 地址的分类。</a> <br>
<a href="#3">3. 画出三次握手和四次挥手的图(状态转移图)。TCP 为什么三次握手,四次挥手?</a> <br>
<a href="#4">4. 为什么收到 Server 端的确认之后,Client 还需要进行第三次“握手”呢?</a> <br>
<a href="#5">5. 为什么要 4 次挥手</a> <br>
<a href="#6">6. 建立连接的第二个 syn 作用是啥? time_wait 状态产生的原因?</a> <br>
<a href="#7">7. 如果网络连接中出现大量 TIME_WAIT 状态所带来的危害?</a> <br>
<a href="#8">8. 如何消除大量 TCP 短连接引发的 TIME_WAIT?</a> <br>
<a href="#9">9. TIME_WAIT 的时间? 当关闭连接时最后一个 ACK 丢失怎么办?</a> <br>
<a href="#10">10. TCP如何保证可靠传输</a> <br>
<a href="#11">11. TCP 建立连接之后怎么保持连接(检测连接断没断)?</a> <br>
<a href="#12">12. TCP 三次握手有哪些漏洞?</a> <br>
<a href="#13">13. TCP 存在的缺陷有哪些?</a> <br>
<a href="#14">14. 三次握手与 accept()函数的关系?</a> <br>
<a href="#15">15. 在三次握手和四次挥手协议中,客户端和服务器端各用到什么函数。</a> <br>
<a href="#16">16. listen 的真正目的?</a> <br>
<a href="#17">17. 如果客户端发起握手请求,服务端无法立刻建立连接应该回应什么?</a> <br>
<a href="#18">18. TCP 与 UDP 的区别(或各自的优缺点),以及各自的用途和使用领域。</a> <br>
<a href="#19">19. 为什么 TCP 比 UDP 安全,但是还有很多用 UDP?</a> <br>
<a href="#20">20. UDP 为何快?</a> <br>
<a href="#21">21. TCP 如何实现流量控制和拥塞控制。tcp 是怎么做错误处理的?</a> <br>
<a href="#22">22. TCP 滑动窗口协议,窗口过大或过小有什么影响?</a> <br>
<a href="#23">23. 在流量控制的过程中,必须考虑传输效率。</a> <br>
<a href="#24">24. 说下 TCP 的黏包 ?</a> <br>
<a href="#25">25. TCP 头部有哪些字段?</a> <br>
<a href="#26">26. UDP 的首部多长,具体包含哪些字段?</a> <br>


### <a name="1">1. 优化查询的方法？</a>
#### 一.OSI 与 TCP/IP 各层的结构与功能,都有哪些协议,协议所占端口号。
![01_1_1](/data/images/Java应届生面试突击/计算机网络/01_1_1.png)
![01_1_2](/data/images/Java应届生面试突击/计算机网络/01_1_2.png)

1. 物理层----定义了为建立、维护和拆除物理链路所需的机械的、电气的、
功能的和规程的特性,其作用是使原始的数据比特流能在物理媒体上传输。具
体涉及接插件的规格、“0”、“1”信号的电平表示、收发双方的协调等内容。
2. 数据链路层----比特流被组织成数据链路协议数据单元(通常称为帧),并
以其为单位进行传输,帧中包含地址、控制、数据及校验码等信息。数据链路
层的主要作用是通过校验、确认和反馈重发等手段,*将不可靠的物理链路改造
成对网络层来说无差错的数据链路*。数据链路层还要协调收发双方的数据传输
速率,即进行*流量控制*,以防止接收方因来不及处理发送方来的高速数据而导
致缓冲器溢出及线路阻塞。
3. 网络层----数据以网络协议数据单元(分组)为单位进行传输。网络层关心
的是通信子网的运行控制,主要解决如何使数据分组跨越通信子网从源传送到
目的地的问题,这就需要在通信子网中进行*路由选择*。另外,为避免通信子网
中出现过多的分组而造成网络阻塞,需要对流入的分组数量进行控制。当分组
要跨越多个通信子网才能到达目的地时,还要解决网际互连的问题。
4. 传输层----是第一个端--端,也即主机--主机的层次。传输层提供的端到端
的透明数据运输服务,使高层用户不必关心通信子网的存在,由此用统一的运
输原语书写的高层软件便可运行于任何通信子网上。传输层还要处理端到端的
差错控制和流量控制问题。
5. 会话层----是进程--进程的层次,其主要功能是组织和同步不同的主机上
各种进程间的通信(也称为对话)。会话层负责在两个会话层实体之间进行对话连
接的建立和拆除。在半双工情况下,会话层提供一种数据权标来控制某一方何
时有权发送数据。会话层还提供在数据流中插入同步点的机制,使得数据传输
因网络故障而中断后,可以不必从头开始而仅重传最近一个同步点以后的数据。
6. 表示层----为上层用户提供共同的数据或信息的语法表示变换。为了让采
用不同编码方法的计算机在通信中能相互理解数据的内容,可以采用抽象的标
准方法来定义数据结构,并采用标准的编码表示形式。表示层管理这些抽象的
数据结构,并将计算机内部的表示形式转换成网络通信中采用的标准表示形式。
数据压缩和加密也是表示层可提供的表示变换功能。
7. 应用层是开放系统互连环境的最高层。不同的应用层为特定类型的网络
应用提供访问 OSI 环境的手段。网络环境下不同主机间的文件传送访问和管理
(FTAM)、传送标准电子邮件的文电处理系统(MHS)、使不同类型的终端和主机通
过网络交互访问的虚拟终端(VT)协议等都属于应用层的范畴。

##### 每层的协议：
![01_1_3](/data/images/Java应届生面试突击/计算机网络/01_1_3.png)
- 物理层:RJ45、CLOCK、IEEE802.3 
- 数据链路:PPP、FR、HDLC、VLAN、MAC
- 网络层:IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGMP
- 传输层:TCP、UDP、SPX
- 会话层:RPC、SQL、NETBIOS、NFS
- 表示层:JPEG、MPEG、ASCII、MIDI
- 应用层:RIP、BGP、FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

##### 协议所占端口号：
- http 80,
- ftp 20,21,
- telnet 23,
- SMTP 25。

### <a name="2">2. IP 地址的分类。</a>
私有地址有:
A 类:10.0.0.0 到 10.255.255.255
B 类:172.16.0.0 到 172.31.255.255
C 类:192.168.0.0 到 192.168.255.255
![01_2_1](/data/images/Java应届生面试突击/计算机网络/01_2_1.png)

### <a name="3">3. 画出三次握手和四次挥手的图(状态转移图)。TCP 为什么三次握手,四次挥手?</a>


#### 3 次握手过程状态:
- LISTEN: 表示服务器端的某个 SOCKET 处于监听状态,可以接受连接了。
- SYN_SENT: 当客户端 SOCKET 执行 CONNECT 连接时,它首先发送 SYN 报文,因
此也随即它会进入到了 SYN_SENT 状态,并等待服务端发送三次握手中的第 2 个报文。
SYN_SENT 状态表示客户端已发送 SYN 报文。
- SYN_RCVD: 这个状态表示接收到了 SYN 报文,在正常情况下,这个状态是服务器端
的 SOCKET 在建立 TCP 连接时的三次握手会话过程中的一个中间状态,很短暂,基本上
用 netstat 你是很难看到这种状态的,除非你特意写了一个客户端测试程序,故意将三次

TCP 握手过程中最后一个 ACK 报文不予发送。因此这种状态时,当收到客户端的 ACK 报
文后,它会进入到 ESTABLISHED 状态。(服务器端)
- ESTABLISHED:表示连接已经建立了。

#### 4 次挥手过程状态:
- FIN_WAIT_1: 这个状态要好好解释一下,其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真
正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是:FIN_WAIT_1 状态实际上
是当 SOCKET 在 ESTABLISHED 状态时,它想主动关闭连接,向对方发送了 FIN 报文,
此时该 SOCKET 即进入到 FIN_WAIT_1 状态。而当对方回应 ACK 报文后,则进入到
- FIN_WAIT_2 状态,当然在实际的正常情况下,无论对方何种情况下,都应该马上回应 ACK
报文,所以 FIN_WAIT_1 状态一般是比较难见到的,而 FIN_WAIT_2 状态还有时常常可以
用 netstat 看到。(主动方持有的状态)
FIN_WAIT_2:
上面已经详细解释了这种状态,实际上 FIN_WAIT_2 状态下的 SOCKET,
表示半连接,也即有一方要求 close 连接,但另外还告诉对方,我暂时还有点数据需要传
送给你(ACK 信息),稍后再关闭连接。(主动方的状态)
- TIME_WAIT: 表示收到了对方的 FIN 报文,并发送出了 ACK 报文,就等 2MSL 后即可
回到 CLOSED 可用状态了。
如果 FIN_WAIT_1 状态下,收到了对方同时带 FIN 标志和 ACK
标志的报文时,可以直接进入到 TIME_WAIT 状态,而无须经过 FIN_WAIT_2 状态。(主
动方的状态)。
- CLOSING(比较少见): 表示双方同时关闭连接。如果双方几乎同时调用 close 函数,
那么会出现双方同时发送 FIN 报文的情况,就会出现 CLOSING 状态,表示双方都在关闭
连接。这种状态比较特殊,实际情况中应该是很少见,属于一种比较罕见的例外状态。正
常情况下,当你发送 FIN 报文后,按理来说是应该先收到(或同时收到)对方的 ACK 报
文,再收到对方的 FIN 报文。但是 CLOSING 状态表示你发送 FIN 报文后,并没有收到对
方的 ACK 报文,反而却收到了对方的 FIN 报文。什么情况下会出现此种情况呢?其实细
想一下,也不难得出结论:那就是如果双方几乎在同时 close 一个 SOCKET 的话,那么
就出现了双方同时发送 FIN 报文的情况,也即会出现 CLOSING 状态,表示双方都正在关
闭 SOCKET 连接。
- CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。当对方 close 一个 SOCKET
后发送 FIN 报文给自己,你系统毫无疑问地会回应一个 ACK 报文给对方,此时则进入到
CLOSE_WAIT 状态。接下来,实际上你真正需要考虑的事情是察看你是否还有数据发送
给对方,如果没有的话,那么你也就可以 close 这个 SOCKET,发送 FIN 报文给对方,
也即关闭连接。所以你在 CLOSE_WAIT 状态下,需要完成的事情是等待你去关闭连接。
(被动方的状态)

- LAST_ACK: 这个状态还是比较容易好理解的,它是被动关闭一方在发送 FIN 报文后,
最后等待对方的 ACK 报文。当收到 ACK 报文后,也即可以进入到 CLOSED 可用状态了。
(被动方的状态)。
- CLOSED: 表示连接中断。 <br>
&ensp;&ensp;&ensp;&ensp;
    首先 Client 端发送连接请求报文,Server 段接受连接后回复 ACK 报文,并为这次连接
分配资源。Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文,并分配资源,这样
TCP 连接就建立了。 <br>
&ensp;&ensp;&ensp;&ensp;
    ACK TCP 报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端
这个序列号之前的数据段都收到了.比如,确认号为 X,则表示前 X-1 个数据段都收到了,只有
当 ACK=1 时,确认号才有效,当 ACK=0 时,确认号无效,这时会要求重传数据,保证数据的完整
性. <br>
&ensp;&ensp;&ensp;&ensp;
    SYN 同步序列号,TCP 建立连接时将这个位置 1。 <br>
&ensp;&ensp;&ensp;&ensp;
    FIN 发送端完成发送任务位,当 TCP 完成数据传输需要断开时,提出断开连接的一方将
这位置 1。 <br>
*【注意】中断连接端可以是 Client 端,也可以是 Server 端。* <br>
&ensp;&ensp;&ensp;&ensp;
    假设 Client 端发起中断连接请求,也就是发送 FIN 报文。Server 端接到 FIN 报文后,
意思是说"我 Client 端没有数据要发给你了",但是如果你还有数据没有发送完成,则不必急
着关闭 Socket,可以继续发送数据。所以你先发送 ACK,"告诉 Client 端,你的请求我收
到了,但是我还没准备好,请继续你等我的消息"。这个时候 Client 端就进入 FIN_WAIT 状
态,继续等待 Server 端的 FIN 报文。当 Server 端确定数据已发送完成,则向 Client 端发
送 FIN 报文,"告诉 Client 端,好了,我这边数据发完了,准备好关闭连接了"。Client 端收
到 FIN 报文后,"就知道可以关闭连接了,但是他还是不相信网络,怕 Server 端不知道要
关闭,所以发送 ACK 后进入 TIME_WAIT 状态,如果 Server 端没有收到 ACK 则可以重传。
“,Server 端收到 ACK 后,"就知道可以断开连接了"。Client 端等待了 2MSL 后依然没有收
到回复,则证明 Server 端已正常关闭,那好,我 Client 端也可以关闭连接了。Ok,TCP
连接就这样关闭了!

netstat 可以看到 tcp 的哪些状态?
netstat 查看 TCP 状态值。
https://www.cnblogs.com/ftl1012/p/netstat.html
#### 整个过程 Client 端所经历的状态如下:
![01_3_1](/data/images/Java应届生面试突击/计算机网络/01_3_1.png)

#### Server 端所经历的过程如下:
![01_3_2](/data/images/Java应届生面试突击/计算机网络/01_3_2.png)
![01_3_3](/data/images/Java应届生面试突击/计算机网络/01_3_3.png)

*【注意】* 在 TIME_WAIT 状态中,如果 TCP client 端最后一次发送的 ACK 丢失了,它将
重新发送。TIME_WAIT 状态中所需要的时间是依赖于实现方法的。典型的值为 30 秒、1
分钟和 2 分钟。等待之后连接正式关闭,并且*所有的资源(包括端口号)都被释放*。
![01_3_4](/data/images/Java应届生面试突击/计算机网络/01_4_1.png)

研究过 backlog 含义的朋友都很容易理解上图。这两个队列是内核实现的,当服务器
绑定、监听了某个端口后,这个端口的 SYN 队列(未完成握手队列)和 ACCEPT 队列(已
完成握手队列)就建立好了。客户端使用 connect 向服务器发起 TCP 连接,当图中 1.1 步
骤客户端的 SYN 包到达了服务器后,内核会把这一信息放到 SYN 队列中,同时回一个
SYN+ACK 包给客户端。一段时间后,在图中 2.1 步骤中客户端再次发来了针对服务器 SYN
包的 ACK 网络分组时,内核会把连接从 SYN 队列中取出,再把这个连接放到 ACCEPT
队列中。而服务器在第 3 步调用 accept 时,其实就是直接从 ACCEPT 队列中取出已经建
立成功的连接套接字而已。

### <a name="4">4. 为什么收到 Server 端的确认之后,Client 还需要进行第三次“握手”呢?</a>

采用三次握手是为了*防止失效的连接请求报文段突然又传送到主机 B *,因而产生错
误。
“已失效的连接请求报文段”的产生在这样一种情况下: client 发出的第一个连接请求报
文段并没有丢失,而是在某个网络结点长时间的滞留了(因为网络并发量很大在某结点被
阻塞了),以致延误到连接释放以后的某个时间才到达 server。*本来这是一个早已失效的
报文段。但 server 收到此失效的连接请求报文段后,就误认为是 client 再次发出的一个新
的连接请求。于是就向 client 发出确认报文段,同意建立连接。假设不采用“三次握手”,
那么只要 server 发出确认,新的连接就建立了。由于现在 client 并没有发出建立连接的请
求,因此不会理睬 server 的确认,也不会向 server 发送数据。但 server 却以为新的运输
连接已经建立,并一直等待 client 发来数据。这样,server 的很多资源就白白浪费掉了*。
采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况,client 不会向 server 的
确认发出确认。server 由于收不到确认,就知道 client 并没有要求建立连接。”。*主要目的
防止 server 端一直等待,浪费资源。*
![01_4_1](/data/images/Java应届生面试突击/计算机网络/01_4_1.png)

&ensp;&ensp;&ensp;&ensp;
    如果两次握手的话,客户端有可能因为网络阻塞等原因会发送多个请求报文,
这时服务器就会建立连接,浪费掉许多服务器的资源。


### <a name="5">5. 为什么要 4 次挥手</a>
&ensp;&ensp;&ensp;&ensp;
    *确保数据能够完成传输*。 <br>
&ensp;&ensp;&ensp;&ensp;
    但关闭连接时,当收到对方的 FIN 报文通知时,它仅仅表示对方没有数据发送给你了;
但未必你所有的数据都全部发送给对方了,所以你可以未必会马上会关闭 SOCKET,也即你可
能还需要发送一些数据给对方之后,再发送 FIN 报文给对方来表示你同意现在可以关闭连
接了,*所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。* <br>
&ensp;&ensp;&ensp;&ensp;
    TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是*全双工模
式*,这就意味着,当主机 1 发出 FIN 报文段时,只是表示主机 1 已经没有数据要发送了,
主机 1 告诉主机 2,它的数据已经全部发送完毕了;但是,这个时候主机 1 还是可以接受来
自主机 2 的数据;当主机 2 返回 ACK 报文段时,表示它已经知道主机 1 没有数据发送了,
但是主机 2 还是可以发送数据到主机 1 的;当主机 2 也发送了 FIN 报文段时,这个时候就
表示主机 2 也没有数据要发送了,就会告诉主机 1,我也没有数据要发送了,之后彼此就会
愉快的中断这次 TCP 连接。 <br>


### <a name="6">6. 建立连接的第二个 syn 作用是啥? time_wait 状态产生的原因?</a>
#### 建立连接的第二个 syn 作用是啥?
&ensp;&ensp;&ensp;&ensp;
    *因为客户端发送的 syn 可能过了好久才到达服务端,而此时客户端超时重传的 SYN 已
经到达服务端,那么后来的 SYN 就是无效的,如果不发第二个 syn 查询客户端是否有效的
话,服务端就会监听这个延迟到达的请求,造成资源的浪费。所以可以强制发送一个 SYN
询问客户端之前的请求是否有效。*

#### time_wait 状态产生的原因?
1. 可靠地实现 TCP 全双工连接的终止 <br>
&ensp;&ensp;&ensp;&ensp;
    我们必须要假想网络是不可靠的,你无法保证你最后发送的 ACK 报文会一定被对方收
到,因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为*超时*未收到 ACK 报文,而重发 FIN
报文,client *必须维护这条连接的状态(保持 time_wait,具体而言,就是这条 TCP 连接
对应的(local_ip, local_port)资源不能被立即释放或重新分配) *以便*可以重发丢失的
ACK* ,如果主动关闭端不维持 TIME_WAIT 状态,而是处于 CLOSED 状态,主动关闭端将会响
应一个 RST,结果 server 认为发生错误,导致服务器端不能正常关闭连接。所以这个
TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。所以,当客户端等待 2MSL(2
倍报文最大生存时间)后,没有收到服务端的 FIN 报文后,他就知道服务端已收到了 ACK
报文,所以客户端此时才关闭自己的连接。
2. 允许老的重复分节在网络中消逝 <br>
&ensp;&ensp;&ensp;&ensp;
    如果 TIME_WAIT 状态保持时间不足够长 ( 比如小于 2MSL) ,第一个连接就正常终止
了。 第二个拥有相同四元组(local_ip, local_port, remote_ip,remote_port)的连接出
现(建立起一个相同的 IP 地址和端口之间的 TCP 连接),而第一个连接的重复报文到达,
干扰了第二个连接。 TCP 实现必须防止某个连接的重复报文在连接终止后出现,所以让
TIME_WAIT 状态保持时间足够长 (2MSL) ,连接相应方向上的 TCP 报文要么完全响应完
毕,要么被丢弃。建立第二个连接的时候,不会混淆。 <br>

### <a name="7">7. 如果网络连接中出现大量 TIME_WAIT 状态所带来的危害?</a>
&ensp;&ensp;&ensp;&ensp;
    如果系统中有很多 socket 处于 TIME_WAIT 状态,当需要创建新的 socket 连接的时
候可能会受到影响,这也会影响到系统的扩展性。 <br>
&ensp;&ensp;&ensp;&ensp;
    之所以 TIME_WAIT 能够影响系统的扩展性是因为在一个 TCP 连接中,一个 Socket 如果
关闭的话,它将保持 TIME_WAIT 状态大约 1-4 分钟 。如果很多连接快速的打开和关闭的
话,系统中处于 TIME_WAIT 状态的 socket 将会积累很多,由于本地端口数量的限制,同一
时间只有有限数量的 socket 连接可以建立,如果太多的 socket 处于 TIME_WAIT 状态,你
会发现,由于用于新建连接的本地端口太缺乏,将会很难再建立新的对外连接。

### <a name="8">8. 如何消除大量 TCP 短连接引发的 TIME_WAIT?</a>
1. *可以改为长连接*,但代价较大,长连接太多会导致服务器性能问题,而且 PHP 等脚
本语言,需要通过 proxy 之类的软件才能实现长连接;
2. 修改 ipv4.ip_local_port_range,增大可用端口范围,但只能缓解问题,不能根本
解决问题;
3. 客户端程序中设置 socket 的 *SO_LINGER* 选项;
4. 客户端机器打开 tcp_tw_recycle 和 tcp_timestamps 选项;
5. 客户端机器打开 tcp_tw_reuse 和 tcp_timestamps 选项;
6. 客户端机器设置 tcp_max_tw_buckets 为一个很小的值;


### <a name="9">9. TIME_WAIT 的时间? 当关闭连接时最后一个 ACK 丢失怎么办?</a>
#### TIME_WAIT 的时间?
&ensp;&ensp;&ensp;&ensp;
    就是 2 个报文最长生存时间(2MSL),1 个 MSL 在 RFC 上建议是 2 分钟,而实现传统上
使用 30 秒,因而,*TIME_WAIT 状态一般维持在 1-4 分钟。*

#### 当关闭连接时最后一个 ACK 丢失怎么办?
&ensp;&ensp;&ensp;&ensp;
    如果最后一个 ACK 丢失的话,TCP 就会认为它的 FIN 丢失,进行重发 FIN。
在客户端收到 FIN 后,就会设置一个 2MSL 计时器,2MSL 计时器可以使客户等
待足够长的时间,使得在 ACK 丢失的情况下,可以等到下一个 FIN 的到来。如
果在 TIME-WAIT 状态汇总有一个新的 FIN 到达了,客户就会发送一个新的 ACK,
并重新设置 2MSL 计时器。 <br>
&ensp;&ensp;&ensp;&ensp;
    如果重传 FIN 到达客户端时,客户端已经进入 CLOSED 状态时,那么客户就
永远收不到这个重传的 FIN 报文段,服务器收不到 ACK,服务器无法关闭连接。 <br>

### <a name="10">10. TCP如何保证可靠传输?</a>
http://www.cnblogs.com/deliver/p/5471231.html

### <a name="11">11. TCP 建立连接之后怎么保持连接(检测连接断没断)?</a>
### <a name="12">12. TCP 三次握手有哪些漏洞?</a>
### <a name="13">13. TCP 存在的缺陷有哪些?</a>
### <a name="14">14. 三次握手与 accept()函数的关系?</a>
### <a name="15">15. 在三次握手和四次挥手协议中,客户端和服务器端各用到什么函数。</a>
https://www.cnblogs.com/xuan52rock/p/9454696.html
### <a name="16">16. listen 的真正目的?</a>
### <a name="17">17. 如果客户端发起握手请求,服务端无法立刻建立连接应该回应什么?</a>
### <a name="18">18. TCP 与 UDP 的区别(或各自的优缺点),以及各自的用途和使用领域。</a>
### <a name="19">19. 为什么 TCP 比 UDP 安全,但是还有很多用 UDP?</a>
### <a name="20">20.  UDP 为何快?</a>
### <a name="21">21. TCP 如何实现流量控制和拥塞控制。tcp 是怎么做错误处理的?</a>
### <a name="22">22. TCP 滑动窗口协议,窗口过大或过小有什么影响?</a>
### <a name="23">23. 在流量控制的过程中,必须考虑传输效率。</a>
### <a name="24">24. 说下 TCP 的黏包 ?</a>
### <a name="25">25. TCP 头部有哪些字段?</a>
### <a name="26">26. UDP 的首部多长,具体包含哪些字段?</a>

---
### 搬运工信息
Author:Jason Lou <br>
Email:vip.iotworld@gmail.com <br>
Blog:https://blog.csdn.net/qq_21508727 <br>
Github:https://github.com/JGPY/JavaGuideBooster <br>
---
